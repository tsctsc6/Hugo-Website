+++
date = '2025-05-20T16:47:58+08:00'
draft = false
title = '计算机图形学-光栅化'
categories = ['Sub Sections']
math = true
+++

光栅化, Rasterization.

经过视图变换之后，所有的东西都处于 $[-1, 1]^3$ 之中。光栅化就是把物体转变为图像显示。

Raster，在德语中是"屏幕(screen)"的意思。

屏幕(screen)是像素(pixel)数组。

像素(pixel)，是"picture element"的缩写。在理想状态下，每一个像素是只有单一颜色的小区域。

显示屏，称为"光栅成像设备"。

## 屏幕空间(screen space)
规定了像素的坐标。

* 像素的坐标 $(x, y)$ 是整数。
* 像素的坐标 $(x, y)$ 的范围是 $(0, 0)$ 到 $(w - 1, h - 1)$ 。
* 像素 $(x, y)$ 的中心是 $(x + 0.5, y + 0.5)$ 。
* 整个屏幕的覆盖范围是 $(0, 0)$ 到 $(w, h)$ 。

在真正的光栅化之前，我们先把 $[-1, 1]^3$ 的东西变换到 $[0, w] \times [0, h]$ 中。先不管 $z$ 坐标，容易写出变换矩阵:
$$\begin{bmatrix} \frac{w}{2} & 0 & 0 & \frac{w}{2} \\\\ 0 & \frac{h}{2} & 0 & \frac{h}{2} \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \end{bmatrix}$$

## 三角形(Triangle)
* 三角形是最基本的平面图形。
* 任何多边形都能使用三角形组合。
* 给定三个点，一定可以确定一个平面。
* 一个点是否在三角形内部，判断是十分简单的。
* 方便[插值](../Shading/index.md#插值)。插值就是说，知道三角形三个点的状态信息(比如颜色)，就可以推测出三角形内任意一点的状态信息(平滑地)。

### 判断一个点是否在三角形内
假设有三个点 $P_1, \, P_2, \, P_3$ ，判断点 $D$ 是否在 $\triangle P_1P_2P_3$ 内部。

如果是在二维空间，自行扩展 $z$ 坐标，通常 $z = 0$ 。

构造向量 $\overrightarrow{P_1P_2}, \, \overrightarrow{P_2P_3}, \, \overrightarrow{P_3P_1}$ ，注意轮换对称性。

如果 $\overrightarrow{P_1P_2} \times \overrightarrow{P_1D}, \, \overrightarrow{P_2P_3} \times \overrightarrow{P_2D}, \, \overrightarrow{P_3P_1} \times \overrightarrow{P_3D}$ 这三个向量是同方向，说明点 $D$ 在 $\triangle P_1P_2P_3$ 内部。否则点 $D$ 不在 $\triangle P_1P_2P_3$ 内部。如果出现了零向量，说明点 $D$ 在 $\triangle P_1P_2P_3$ 的边上。

## 采样
给定一个连续的函数 $f$ ，对一些 $x$ ，去求 $f(x)$ 。

采样就是把连续函数离散化的过程。

## 使用采样法，对三角形进行光栅化
对于屏幕空间的每一个像素，判断像素中心是否在三角形内部。如果在内部，那么这个像素的颜色就是三角形的颜色。

### 如果像素中心刚好在三角形的边上
自己说了算。也可以不做任何处理。可以认为这个像素在三角形内，也可以认为不在三角形内。在一些图形学的库中，也有一些特殊的规定。

### 要对所有像素进行遍历吗?
一般来说，一个三角形只覆盖了一个比较小的区域。屏幕的大部分区域，显然是不可能被三角形覆盖的。

我们只需要判断一下，三个点的最小和最大的 $x, y$ 值，就能划定一个长方形，只有在这个长方形中的像素，才有可能被三角形覆盖。这个长方形被称为"边界框(Bounding Box)"。

## Sampling Artifacts
Artifacts: 瑕疵，在图形学中，表示"看起来不太对的东西"。常见的 Artifacts 有: Aliasing(锯齿)，摩尔纹， Wagon wheel effect 等等。

出现这些现象的根本原因是采样率相对于原始信号的频率来说，太低了，见[采样定理 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86)。

解决这个问题的方法，当然是提高采样率；放到光栅化这个场景中，就是提高屏幕的分辨率。但是这个方法有时不容易做到，所以我们还需要其他方法。

我们还可以降低原始信号的频率。

在三角形的三条边附近，把颜色渐变，而不是一下子改变颜色。换句话说，就是把三角形进行"模糊处理"，然后再进行采样。而这个"模糊处理"，在信号处理中，就是"低通滤波"。

"低通滤波"可以使用卷积完成。

卷积定理: 时域卷积 = 频域乘积；时域乘积 = 频域卷积

### Muti Spample Antialiasing (MSAA)
对于每个像素，再把它划分为多个子像素，再进行采样。根据每一个像素的子像素，在三角形内部的数量，来决定一个"中间颜色"。

最简单的想法是，把每一个像素均匀分割为 2x2 ，4x4 之类的小方块。但是这样增加了许多计算量。所以有其他花里胡哨的划分方式。

### Fast Approximate AA (FXAA)
先得到一张有锯齿的图像，然后经过一些图像处理，把锯齿模糊掉。

### Temporal AA (TAA)
根据上一帧的信息来模糊锯齿。

## 物体遮挡以及物体可见性
### 油画家算法(Painter's Algorithm)
先画远处的物体，再画近处的物体，覆盖掉远处的物体，这样就能体现正确的遮挡关系了。

但是，如何判断三维空间中面的远近？

### Z-Buffer Algorithm
对于每一个像素，记录它的最浅的深度。在光栅化时，如果这个面，对应像素的深度，没有浅于记录的最浅的深度，那么就不渲染了。

那么一个像素的深度如何获得? 可以使用[插值](#插值)方法获得。

* frame buffer: 存储颜色信息。
* depth buffer(Z-Buffer): 存储深度信息。

通过该算法光栅化，无论先渲染那个三角形，得到的结果是相同的（如果没有相同深度的像素的话）。

对于透明的物体，想必有一个透明度。于是我们不直接覆盖颜色，转而利用透明度，对原先的颜色进行一些处理。
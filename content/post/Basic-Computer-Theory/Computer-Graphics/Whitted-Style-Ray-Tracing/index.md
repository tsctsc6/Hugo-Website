+++
date = '2025-05-20T16:51:33+08:00'
draft = false
title = '计算机图形学-Whitted-Style Ray Tracing'
categories = ['Sub Sections']
math = true
+++

## 简单描述
在 [Ray Casting](../Shadow/index.md#ray-castinglocal-only) 的基础上，考虑 eye ray 多次反射和折射。

eye ray 被称为 primary ray ， eye ray 之后的反射和折射光线称为 secondary ray 。

对于每一个 intersection point ，都做 [Ray Casting](../Shadow/index.md#ray-castinglocal-only) 的第三步，然后根据能量损失，反射和折射能量的比例，叠加到像素点上。

## 具体实现
### 求光线与模型表面的交点
#### 光线的数学定义
一个点和一个方向就可以描述一条光线，即，一个点的坐标和一个单位向量。那么在光线上的点，都满足以下等式:

$${\bf{r}}(t) = {\bf{o}} + t{\bf{d}} ,\quad 0 \leq t < \infty$$

其中， $\bf{o}$ 是光源点， $\bf{d}$ 是单位向量，表示光线的方向。

#### 光线与隐式表面的交点
假如有隐式表面 ${\bf p}: f({\bf p}) = 0$ ，求其与光线 ${\bf{r}}(t) = {\bf{o}} + t{\bf{d}} ,\quad 0 \leq t < \infty$ 的交点。

显然，解方程 ${\bf p}: f({\bf{o}} + t{\bf{d}}) = 0$ 即可。只需要正实数的根。

在这个场景下，我们往往不需要方程的精确解，只需要使用数值分析的方法获得可接受精度的解就可以了。所以，二分法， Newton 法， Picard 法，启动！！

#### 光线与显式表面的交点
##### 朴素的算法
显式表面由多个三角形组成。只要判断每个三角形是否和光线相交即可。具体步骤是，求出三角形平面和光线的交点，再判断交点是否在三角形内。

Möller Trumbore Algorithm: 通过一些线性代数的知识，把"求出三角形平面和光线的交点，再判断交点是否在三角形内"的两步直接合成为一步，方便计算机直观的求解。当然，其实本质是一样的。

##### 加速的算法
但是，一个物体是由许多三角形组成，判断每个三角形，效率太低。

首先，对三角形生成一个包围盒(三维的, Bounding Volumes, 概念类似于[这个](../Rasterization/index.md#要对所有像素进行遍历吗))。一般我们使用的是轴对齐包围盒(Axis-Aligned Bounding Box, AABB)，使用 3 对数字(对应 x, y, z, 3 组平面)来描述，该物体的点不会超过的范围。

那么如何快速判断光线的哪一部分进入包围盒? 首先，对于 3 对数字，判断对应的 $t$ 值。这个的计算量是十分少的。比如包围盒的 $x_1 = 1, x_2 = 3$ ，那么据此得出 $t$ 的值。于是我们可以得出 3 对 $t$ 值。对这 3 对 $t$ 值求交集，就可以得到光线进入包围盒的部分。如果这交集不是空集，并且离开的 $t > 0$ ，说明光线会进入包围盒。

快速判断的基本方法是，先把整个空间均匀划分为多个 AABB ，并对其分类: 有物体表面和没有物体表面。发射光线，光线会依次经过一些 AABB 。对于每个经过的 AABB ，如果该 AABB 有物体表面，那么继续判断光线是否与物体相交。

那么如何判断光线依次经过哪些 AABB ? 首先，由光线的起点处就可以确定初始的 AABB 。然后，根据光线的方向，确定它从哪个面出去，这样就能确定下一个 AABB 是谁了。

那么应该把空间划分为多少个格子呢? 如果格子太少，那么加速效果不明显；如果格子太多，那么在判断光线与格子相交就会浪费太多性能。根据启发式算法，一般划分为 27 * 物体数量 的格子。

这种均匀划分格子的做法，在空间中物体分布比较均匀的时候是比较有效的；反之效果就不好。

##### Spatial Partitions(空间划分)
我们自然想到，只要在物体稀疏的区域，格子划分得大一点，物体密集的区域，格子划分得小一点。于是出现了几种空间划分算法。

###### Oct-Tree(八叉树)
首先把空间划分为 8 份，就是 2 * 2 * 2 份。对于每一个子空间，继续划分为 8 份。直到该子空间里面的物体数量足够少。

这个方法在二维空间中是四叉树。所以这个方法，是和维度高度相关的。这个方法不适合高维空间。

###### KD-Tree
做法和 Oct-Tree 类似，但是每次只把空间划分为 2 份，沿着 x, y, z 轴交替轮换进行划分。每次划分也不一定要在正中间划分。实际的物体只保存在叶子节点中。

###### BSP-Tree
做法和 KD-Tree 类似，但是是斜着划分空间。这样其实不是 AABB ，计算相对麻烦。

###### Problems
1. 求一个包围盒和一个三角形是否有交集，这是复杂的，难写的。
2. 一个物体或者三角形，可以出现在多个包围盒里面。这导致光线在计算物体相交时，出现重复计算的问题。

##### Object Partitions(物体划分)
###### Bounding Volumes Hierarchy(BVH)
得到一堆物体后，先把这些物体分成两份，分别求它们的包围盒。对于每一个包围盒里面的物体，继续分成两份，分别求它们的包围盒。如此递归下去，直到每个包围盒里面的物体数量少到一定的程度。

缺点: 包围盒可能会重叠。所以具体如何划分，还是很有讲究的(就是尽量使包围盒重叠得少)。

1. 为了保证划分的均匀，每次都垂直于最长的轴划分。
2. 每一步划分的时候，以中间的物体为界，来划分。这样使得每一个包围盒的物体数量基本一致。(计算物体中心坐标，使用快速选择算法，时间复杂度 $O(n)$)

#### 额外内容: 如何判断一个点是否在某物体内?
要判断的点是 $\bf o$ ，把 $\bf o$ 当作光源。这个物体必须是闭合的，否则没得说。

有一条从 $\bf o$ 发出的光线，与物体表面有奇数个交点 $\iff$ $\bf o$ 在物体内

有一条从 $\bf o$ 发出的光线，与物体表面有偶数个交点 $\iff$ $\bf o$ 在物体外

射线的方向需要小心选择，避免穿过曲面上的边界区域。当然，这在计算机世界是不可能的。因为边界的解是精确解，而计算机的浮点数运算不是精确的。

+++
date = '2025-05-25T18:02:04+08:00'
draft = false
title = '数据库-关系型数据库'
categories = ['Sub Sections']
math = true
mermaid = false
+++

关系型数据库，要使用关系模型。首先简单介绍关系模型的相关概念：

1. **关系**：一个关系对应实体-联系方法中的一个实体类型。通常也称为一张表。
1. **属性**：对应实体-联系方法中的实体类型的属性。表中的一列即为一个属性。
1. **域**：属性的取值范围。
1. **元组**：表中的一行即为一个元组，即某关系的一条具体的数据记录。
1. **主键**：也称主码。主键是关系中的某个属性或属性组，它可以唯一确定一个元组。
1. **分量**：元组中的一个属性值。
1. **关系模式**：对关系的描述，一般表示为“关系名（属性1，属性2，.....，属性n）”。

## 关系数据结构及形式化定义
关系模型是建立在集合代数的基础上的，因此从集合论角度给出关系数据结构的形式化定义。

### 域
域(Domain)是一组具有相同数据类型的值的集合。

> 例如，自然数、整数、实数、长度小于 25 字节的字符串集合、{0, 1}、{男, 女}、大于等于 0 且小于等于 100 的正整数等，都可以是域。

### 笛卡尔积
笛卡尔积(Cartesian Product)是域上面的一种集合运算。

给定一组域 $D_1, D_2, \cdots, D_n$ ，允许其中某些域是相同的。 $D_1, D_2, \cdots, D_n$ 的笛卡尔积为：

$$D_1 \times D_2 \times \cdots \times D_n = \{ (d_1, d_2, \cdots, d_n) \mid d_i \in D_i, \quad i = 1, 2, \cdots, n \}$$

笛卡尔积中每个元素 $(d_1, d_2, \cdots, d_n)$ 称为一个 n 元组，或简称元组。

笛卡尔积可表示为一个二维表，表中每行对应一个元组，表中每一列的值来自一个域。

> 比如， $A = \{a, b\}, B = \{0, 1, 2 \}$ ，则：
> $$A \times B = \{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2) \}$$
> $$B \times A = \{(0, a), (0, b), (1, a), (1, b), (2, a), (2, b) \}$$
> $A \times B$ 可以表示为下面的表格：
> | A | B |
> | :--: | :--: |
> | a | 0 |
> | a | 1 |
> | a | 2 |
> | b | 0 |
> | b | 1 |
> | b | 2 |

### 关系
$D_1 \times D_2 \times \cdots \times D_n$ 的子集叫作在域 $D_1, D_2, \cdots, D_n$ 上的关系(Relation)，表示为 $R(D_1, D_2, \cdots, D_n)$ 。其中， $R$ 是关系名称， $n$ 是关系的目或度(Degree)。

关系也是一个二维表，每行对应一个元组，每列对应一个域，每列称为属性。

若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码(Candidate key)。

若一个关系有多个候选码，则选定其中一个或多个为主码(Primary key)。

候选码的多个属性称为主属性(Prime attribute)，不包含在任何候选码中的属性称为非主属性；最简单的情况下，候选码只包含一个属性，如果关系模式的所有属性都是这个关系的候选码，则称为全码(All-key)。

## 关系操作
关系模型中常用的关系操作包括查询(Read)操作和更新操作（插入(Create)、删除(Delete)、修改(Update)）这两大部分。更新操作没什么好说的，这关系到数据库底层采用了何种数据结构。查询操作分为：选择(Select)、投影(Project)、连接(Join)、除(Divide)、并(Union)、差(Except)、交(Intersection)、笛卡尔积等；其中：**选择、投影、并、差、笛卡尔积**是 5 种基本操作，其他操作是可以用基本操作来定义和导出的。

## 关系的完整性
关系模型的完整性规则是对关系的某种约束条件，关系模型中有三类完整性约束：

1. **实体完整性(Entity Integrity)**：关系模型以主键作为唯一性标识，主键中的属性不能取空值。
1. **参照完整性(Referential Integrity)**：参照完整性要求在一个关系数据库中，对于所有使用外键的情况，每个外键值要么为空，要么必须在另一个表的主键中存在对应的值。这样的规则保证了数据之间的正确引用，防止了数据的不一致性。
1. **用户自定义完整性(User-defined Integrity)**：反映某一具体应用所涉及的数据必须满足的语义要求。

## 关系代数
### 选择
选择运算是从关系 $R$ 中选取使逻辑表达式 $F$ 为真的元组，是从行的角度进行的运算。记作：

$$\sigma_F(R)$$

> 例如，选择信息系（IS系）全体学生： $\sigma_{Sdept='IS'}(Student)$

### 投影
关系 $R$ 上的投影是从 $R$ 中选择出若干属性列组成新的关系，是从列的角度进行运算。在投影运算中，如果设置“去除重复行”，就可能会去掉某些行。记作：

$$\pi_{D'_1, D'_2, \cdots, D'_n}(R)$$

> 例如，投影学生的姓名和所在系： $\pi_{Sname, Sdept}(Student)$

### 并
设关系 $R$ 和关系 $S$ 具有相同的目 $n$ （即两个关系都有 $n$ 个属性），且相应的属性取自同一个域，则关系 $R$ 与关系 $S$ 的并(Union)由属于 $R$ 或属于 $S$ 的元组组成。其结果关系仍为 $n$ 目关系。记作：

$$R \cup S = \{ t \mid t \in R \; \vee \; t \in S \}$$

### 差
设关系 $R$ 和关系 $S$ 具有相同的目 $n$ ，且相应的属性取自同一个域，则关系 $R$ 与关系 $S$ 的差(Difference)由属于 $R$ 而不属于 $S$ 的所有元组组成。其结果关系仍为 $n$ 目关系。记作：

$$R - S = \{ t \mid t \in R \; \wedge \; t \notin S \}$$

### 交
设关系 $R$ 和关系 $S$ 具有相同的目 $n$ ，且相应的属性取自同一个域，则关系 $R$ 与关系 $S$ 的交(Intersection Referential integrity)由既属于 $R$ 又属于 $S$ 的元组组成。其结果关系仍为 $n$ 目关系。记作：

$$R \cap S = \{ t \mid t \in R \; \wedge \; t \in S \}$$

### 笛卡尔积
见[上文](#笛卡尔积)。

### 连接
连接(Join)分为 $\theta$ 连接，等值连接，自然连接，外连接，半连接，反连接等等。

这里先定义一个通用的例子，关系 $R$ 的元组如下：

| A | B | C |
| :--: | :--: | :--: |
| a1 | b1 | 5 |
| a1 | b2 | 6 |
| a2 | b3 | 8 |
| a2 | b4 | 12 |

关系 $S$ 的元组如下：

| B | E |
| :--: | :--: |
| b1 | 3 |
| b2 | 7 |
| b3 | 10 |
| b3 | 2 |
| b5 | 2 |

#### $\theta$ 连接
$\theta$ 连接(Theta Join)，基于任意条件 $\theta$ 组合两个关系的元组。条件可以是 $=, \leq, \geq, <, >$ 等。记作：

$$R \bowtie_\theta S$$


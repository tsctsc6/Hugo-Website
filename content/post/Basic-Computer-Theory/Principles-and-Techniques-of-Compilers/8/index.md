+++
date = '2025-05-20T17:20:40+08:00'
draft = false
title = '编译原理-语法制导翻译和中间代码生成'
categories = ['Sub Sections']
math = true
+++

## 属性文法
对编译程序使用的文法符号，可以用“类型”、“值”或“存储位置”来描述它。

属性文法就是附加了一组属性及其运算规则(语义规则)的文法。

文法符号 $X$ 的属性 $t$ 常用 $X.t$ 来表示。

例: 简单的**表达式文法**

$E \to E_1 + T \qquad E.val = E_1.val + T.val$
$E \to T \qquad E.val = T.val$
$T \to T_1 * F \qquad T.val = T_1.val * F.val$
$T \to F \qquad T.val + F.val$
$F \to (E) \qquad F.val = E.val$
$F \to digit \qquad F.val = digit.lexval$

其中，属性 $val$ 表示变量的值， $lexval$ 表示通过解析原来的文本得到的值。

属性分为两类:
* **综合属性**，是从其子结点的属性值计算出来的。
* **继承属性**，是从其兄弟结点和父结点的属性值计算出来的。

## 语法制导翻译
在语法分析过程中，随着分析的步步进展，根据每个产生式所对应的语义规则描述的语义动作，进行翻译的过程称作语法制导翻译，其一般过程如下:
1. 分析输入符号，建立语法树；
2. 从语法分析树得到描述结点属性之间的依赖关系，得到计算次序；
3. 按照语义规则计算属性值。

属性文法的分类:
* S-属性文法，只含有综合属性的属性文法。其属性可以在分析输入符号串的同时自下而上的分析器来计算。
* L-属性文法，既包括综合属性，又包括继承属性。其属性可用深度优先的顺序从左至右计算。

## 翻译模式
翻译模式是语法制导定义的一种便于翻译的书写形式。其中属性与文法符号相对应，语义规则或语义动作用花括号{ }括起来，可被插入到产生式右部的任何合适的位置上。

这是一种语法分析和语义动作交错的表示法，他表达在按深度优先遍历分析树的过程中何时执行语义动作。

例子:
某产生式 $E \to E + \lbrace do \; something \rbrace T$ ，当程序识别完 $+$ 后，就会 $\lbrace do \; something \rbrace$ 。

## 带语义动作的分析树
把[翻译模式](#翻译模式)中的语义规则(花括号括起来的)当成终结符那样照画就行了。只不过用方框框住。

## 中间代码
中间代码的形式有:
* 逆波兰式，又称后缀式
* 语法结构树，又称三元式
* 间接三元式
* 三地址码，又称四元式

设 $Exp = S_1 + Op + S_2$ ， $Op$ 是运算符，则
* $Op + S_1 + S_2$ 为前缀表示法
* $S_1 + Op + S_2$ 为中缀表示法
* $S_1 + S_2 + Op$ 为后缀表示法

结论
* 中缀式丢失了括弧信息,致使运算的次序不确定。
* 前缀式的运算规则: **连续出现的两个操作数**和在之前且紧靠它们的运算符构成一个最小表达式。
* 后缀式的运算规则为: 运算符在式中出现的顺序恰为表达式的运算顺序；每个运算符和在它之前出现且**紧靠它的两个操作数**构成一个最小表达式。

## 后缀表达式
后缀表达式最大的优点是易于计算机处理表达式。常用的算法是使用一个栈:
* 自左至右扫描后缀式。
* 每扫描到运算对象，就进栈；
* 扫描到运算符，若该运算符是二目的，则对栈顶部的两个运算对象实施该运算，并将运算结果代替这两个运算对象而进栈；
* 若是一目运算符，则对栈顶元素执行该运算，并以运算结果代替该元素进栈，最后的结果留在栈顶。

## 三元式和间接三元式
例: $A + B * (C - D) + E / (C - D) \; \^{} \; N$ ，其三元式为: 
1. $(- \quad C \quad D)$
2. $(* \quad B \quad (1))$
3. $(+ \quad A \quad (2))$
4. $(- \quad C \quad D)$
5. $(\; \^{} \; \quad (4) \quad N)$
6. $(/ \quad E \quad (5))$
7. $(+ \quad (3) \quad (6))$

间接三元式为: (间接码表: (1), (2), (3), (1), (4), (5),(6))
1. $(- \quad C \quad D)$
2. $(* \quad B \quad (1))$
3. $(+ \quad A \quad (2))$
4. $(\; \^{} \; \quad (1) \quad N)$
5. $(/ \quad E \quad (4))$
6. $(+ \quad (3) \quad (5))$

三元式和间接三元式的区别是，三元式的(4)在之前已经生成过，间接三元式就直接使用(1)式。此外，间接三元式还有一个间接码表，用于表明间接三元式执行的顺序。

## 四元式
四元式(三地址码)和三元式的主要不同在于，四元式对中间结果的引用必须通过给定的名字，而三元式是通过产生中间结果的三元式编号。也就是说，四元式之间的联系是通过临时变量实现的。

例: $A + B * (C - D) + E / (C - D) \; \^{} \; N$ ，其四元式为:
1. $(- \quad C \quad D \quad T_1)$
2. $(* \quad B \quad T_1 \quad T_2)$
3. $(+ \quad A \quad T_2 \quad T_3)$
4. $(- \quad C \quad D \quad T_4)$
5. $(\; \^{} \; \quad T_4 \quad N \quad T_5)$
6. $(/ \quad E \quad T_5 \quad T_6)$
7. $(+ \quad T_3 \quad T_6 \quad T_7)$

## 构造符号表
符号表，记录了变量、常量、过程名。

| 名称 | 类型 | 层级 | 值 | 地址 | 大小(unit: int) |
| :--: | :--: | :--: | :--: | :--: | :--: |
| a | 常量 | 0 | 25 | null | 1 |
| b | 变量 | 0 | null | 3 | 1 |
| func | 函数 | 0 | null | 入口地址 | 5 |

* 常量不需要分配运行栈空间。
* 变量地址从3开始，因为每个活动记录都有3个基本联系单元。当然，如果变量所在的函数有参数，那么久不是从3开始了。
* 函数的大小是指，在运行栈创建新的活动记录是，需要的大小(基本联系单元 + 函数参数 + 局部变量)。
* 层级用于访问非局部常量和变量。

## 各种语句的翻译
看PPT。

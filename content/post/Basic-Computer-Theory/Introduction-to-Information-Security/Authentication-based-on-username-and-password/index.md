+++
date = '2025-07-30T17:46:36+08:00'
draft = false
title = '根据用户名和口令进行身份验证'
categories = ['Sub Sections']
math = true
+++

本博客介绍服务器如何验证来自客户端的用户名和口令。假设客户端发送了用户名和口令，请求登录。

> "口令"就是我们通常说的"密码"，但其实"密码"这个说法不够准确。"密码"更多是指加密算法的密钥。

## 明文存储口令
显然，最简单的方法是，使用数据库中直接存储用户名与口令。直接把客户端发送用户名与口令，跟数据库中的用户名与口令直接进行比对即可。

但是这种方法有一个致命的问题：数据库直接存储了用户名与口令！如果数据库管理人员是内鬼，或者有一个技术高超的黑客，黑进了数据库，那么所有用户的口令将直接暴露。

## 验证消息摘要
要解决口令容易暴露的问题，可以用以下办法解决：

使用数据库中存储用户名与**口令的[消息摘要](../Message-Digest/index.md)**。收到客户端发送的用户名与口令后，计算口令的消息摘要值，跟数据库中的用户名与口令的消息摘要值进行比对。

但是又有一个问题。消息摘要是会发生碰撞的，即一定存在两个输入，其消息摘要值相同。黑客可以通过一段时间的计算，找到一个口令，其消息摘要与真正口令的消息摘要值相同，这样黑客就能登录了。当然，如果使用较强的消息摘要算法可以一定程度地避免这个问题。

即使如此，黑客仍然可以通过彩虹表攻击破解口令。彩虹表攻击是一种高效的密码破解技术，通过使用预先计算好的哈希值与其对应的明文口令的查找表，快速找到密码。彩虹表的明文口令，一般是常见的弱口令。所以当用户使用了弱口令，就容易被黑客破解。

## 加盐
为了防止彩虹表攻击，可以用以下办法：

使用数据库中存储用户名与（口令 + 一个随机字符串）的消息摘要。这个随机字符串称为"盐值"。收到客户端发送的用户名与口令后，计算（口令 + 盐值）的消息摘要值，跟数据库中的用户名与（口令 + 盐值）的消息摘要值进行比对。

这样，把消息摘要算法的输入值变得复杂，黑客无法轻易找到消息摘要的碰撞了。

> 其实这个盐值和口令结合的方式可以随意定义，可以（口令 + 盐值），也可以（盐值 + 口令），等等。

## PBKDF2
加盐之后，已经比较安全了。但是黑客仍然可以暴力破解，即把所有可能的口令都尝试一次。

可以考虑提高计算难度，即进行消息摘要算法多次。具体算法如下；

输入：

* 口令（ $P$ ）
* 随机盐（ $S$ ）
* 迭代次数（ $c$ ）
* 输出密钥长度（ $dkLen$ ）
* 底层伪随机函数 $PRF$ （通常为 [HMAC 算法](../HMAC-algorithm/index.md)与某种哈希算法的组合）

算法：

$$
T_i = F(P, S, c, i) \\
F(P, S, c, i) = U_1 \oplus U_2 \oplus \cdots \oplus U_c\\
U_1 = PRF(P, S \mid\mid INT(i)) \\
U_j = PRF(P, U_{j-1}) \quad j = 2, 3, \cdots , c
$$

> * $INT(i)$ : 将 $i$ 编码为 4 字节大端整数。（256 => 00 00 01 00）
> * $\oplus$ : 按位异或
> * $\mid\mid$ : 拼接

最终结果是拼接 $T_i$ , $T_1 \mid\mid T_2 \mid\mid \cdots$ ，截取前 $dkLen$ 字节，得到最终派生密钥 $DK$ 。

## Bcrypt and Argon2
但可惜的是，道高一尺，魔高一丈。 PBKDF2 算法虽然提高了黑客暴力破解密码的难度，但是仍然有一些问题。比如，黑客可以使用 GPU 或 FPGA 来加速计算，从而提高暴力破解的速度。所以，我们还有更加重量级的选手: BCrypt 及 Argon2。

这里就不过多介绍了，感兴趣的可以自行了解。

## See Also
[为什么用户密码需要加盐哈希后再存储？](https://blog.coldwind.top/posts/why-password-hash-with-salt/)